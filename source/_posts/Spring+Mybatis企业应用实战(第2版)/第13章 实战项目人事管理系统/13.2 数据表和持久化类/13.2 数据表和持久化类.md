---
title: 13.2 数据表和持久化类
categories: 
  - Spring+Mybatis企业应用实战(第2版)
  - 第13章 实战项目人事管理系统
  - 13.2 数据表和持久化类
date: 2019-06-20 11:23:44
updated: 2019-11-02 01:38:59
abbrlink: a9fcda4f
---
- [13.2 数据表和持久化类](/ReadingNotes/a9fcda4f/#13-2-数据表和持久化类)
    - [13.2.1 设计数据库表](/ReadingNotes/a9fcda4f/#13-2-1-设计数据库表)
    - [13.2.2 设计持久化实体](/ReadingNotes/a9fcda4f/#13-2-2-设计持久化实体)
    - [13.2.3 创建持久化实体类](/ReadingNotes/a9fcda4f/#13-2-3-创建持久化实体类)
        - [User.java](/ReadingNotes/a9fcda4f/#User-java)
        - [Dept.java](/ReadingNotes/a9fcda4f/#Dept-java)
        - [Job.java](/ReadingNotes/a9fcda4f/#Job-java)
        - [Employee.java](/ReadingNotes/a9fcda4f/#Employee-java)
        - [Notice.java](/ReadingNotes/a9fcda4f/#Notice-java)
        - [Document.java](/ReadingNotes/a9fcda4f/#Document-java)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 13.2 数据表和持久化类 #
通过使用`MyBatis`持久层,可以避免使用传统的`JDBC`方式来操作数据库,如此可以使`SQL`语句更加灵活,并且可以直接通过面向对象的方式操作数据。
## 13.2.1 设计数据库表 ##
首先,根据模块功能设计数据库表,具体`SQL`语句如下:
```sql
#创建数据库hrm_db
CREATE DATABASE hrm_db;
#使用数据库hrm_db
USE hrm_db;
#创建表dept_inf
CREATE TABLE dept_inf (
  ID INT(11) NOT NULL AUTO_INCREMENT,
  NAME VARCHAR(50) NOT NULL,
  REMARK VARCHAR(300) DEFAULT NULL,
  PRIMARY KEY (ID)
) ENGINE=INNODB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;
INSERT  INTO dept_inf(ID,NAME,REMARK) VALUES (1,'技术部','技术部'),(2,'运营部','运营部'),(3,'财务部','财务部'),(5,'总公办','总公办'),(6,'市场部','市场部'),(7,'教学部','教学部');
#创建表job_inf
CREATE TABLE job_inf (
  ID INT(11) NOT NULL AUTO_INCREMENT,
  NAME VARCHAR(50) NOT NULL,
  REMARK VARCHAR(300) DEFAULT NULL,
  PRIMARY KEY (ID)
) ENGINE=INNODB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;
INSERT  INTO job_inf(ID,NAME,REMARK) VALUES (1,'职员','职员'),(2,'Java开发工程师','Java开发工程师'),(3,'Java中级开发工程师','Java中级开发工程师'),(4,'Java高级开发工程师','Java高级开发工程师'),(5,'系统管理员','系统管理员'),(6,'架构师','架构师'),(7,'主管','主管'),(8,'经理','经理'),(9,'总经理','总经理');
#创建表user_inf
CREATE TABLE user_inf (
  ID INT(11) NOT NULL AUTO_INCREMENT,
  loginname VARCHAR(20) NOT NULL,
  PASSWORD VARCHAR(16) NOT NULL,
  USERSTATUS INT(11) NOT NULL DEFAULT '1',
  createdate TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  username VARCHAR(20) DEFAULT NULL,
  PRIMARY KEY (ID)
) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
INSERT  INTO user_inf(ID,loginname,PASSWORD,USERSTATUS,createdate,username) VALUES (1,'admin','123456',2,'2016-03-12 09:34:28','超级管理员');
#创建表employee_inf
CREATE TABLE employee_inf (
  ID INT(11) NOT NULL AUTO_INCREMENT,
  DEPT_ID INT(11) NOT NULL,
  JOB_ID INT(11) NOT NULL,
  NAME VARCHAR(20) NOT NULL,
  CARD_ID VARCHAR(18) NOT NULL,
  ADDRESS VARCHAR(50) NOT NULL,
  POST_CODE VARCHAR(50) DEFAULT NULL,
  TEL VARCHAR(16) DEFAULT NULL,
  PHONE VARCHAR(11) NOT NULL,
  QQ_NUM VARCHAR(10) DEFAULT NULL,
  EMAIL VARCHAR(50) NOT NULL,
  SEX INT(11) NOT NULL DEFAULT '1',
  PARTY VARCHAR(10) DEFAULT NULL,
  BIRTHDAY DATETIME DEFAULT NULL,
  RACE VARCHAR(100) DEFAULT NULL,
  EDUCATION VARCHAR(10) DEFAULT NULL,
  SPECIALITY VARCHAR(20) DEFAULT NULL,
  HOBBY VARCHAR(100) DEFAULT NULL,
  REMARK VARCHAR(500) DEFAULT NULL,
  CREATE_DATE TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (ID),
  KEY FK_EMP_DEPT (DEPT_ID),
  KEY FK_EMP_JOB (JOB_ID),
  CONSTRAINT FK_EMP_DEPT FOREIGN KEY (DEPT_ID) REFERENCES dept_inf (ID),
  CONSTRAINT FK_EMP_JOB FOREIGN KEY (JOB_ID) REFERENCES job_inf (ID)
) ENGINE=INNODB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;
INSERT  INTO employee_inf(ID,DEPT_ID,JOB_ID,NAME,CARD_ID,ADDRESS,POST_CODE,TEL, PHONE,QQ_NUM,EMAIL,SEX,PARTY,BIRTHDAY,RACE,EDUCATION,SPECIALITY,HOBBY,REMARK,CREATE_DATE) 
VALUES (1,1,8,'爱丽丝','4328011988','广州天河','510000','020-77777777', '13902001111','36750066','251425887@qq.com',0,'党员','1980-01-01 00:00:00','满','本科','美声','唱歌','四大天王','2016-03-14 11:35:18'),
(2,2,1,'杰克','22623','43234','42427424','42242','4247242','42424', 
'251425887@qq.com',2,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2016-03-14 11:35:18'),
 (3,1,2,'bb','432801197711251038','广州','510000','020-99999999','13907351532', '36750064','36750064@qq.com',1,'党员','1977-11-25 00:00:00','汉','本科','计算机','爬山','无','2016-07-14 09:54:52');
#创建表notice_inf
CREATE TABLE notice_inf (
  ID INT(11) NOT NULL AUTO_INCREMENT,
  TITLE VARCHAR(50) NOT NULL,
  CONTENT TEXT NOT NULL,
  CREATE_DATE TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  USER_ID INT(11) DEFAULT NULL,
  PRIMARY KEY (ID),
  KEY FK_NOTICE_USER (USER_ID),
  CONSTRAINT FK_NOTICE_USER FOREIGN KEY (USER_ID) REFERENCES user_inf (ID)
) ENGINE=INNODB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;
#创建表document_inf
CREATE TABLE document_inf (
  ID INT(11) NOT NULL AUTO_INCREMENT,
  TITLE VARCHAR(50) NOT NULL,
  filename VARCHAR(300) NOT NULL,
  REMARK VARCHAR(300) DEFAULT NULL,
  CREATE_DATE TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  USER_ID INT(11) DEFAULT NULL,
  PRIMARY KEY (ID),
  KEY FK_DOCUMENT_USER (USER_ID),
  CONSTRAINT FK_DOCUMENT_USER FOREIGN KEY (USER_ID) REFERENCES user_inf (ID)
) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
```
## 13.2.2 设计持久化实体 ##
面向对象分析,是指根据系统需求提取应用中的对象,将这些对象抽象成类,再抽取出需要持久化保存的类,这些需要持久化保存的类就是持久化对象(`PO`)。本系统设计了6个持久化类。具体包括:
- `User`。对应用户,包括用户编号、用户名、登录名、密码、状态及建档日期等属性
- `Dept`。对应部门,包括部门编号、部门名称及详细描述等属性。
- `Job`。对应职位,包括职位编号、职位名称及详细描述等属性。
- `Employee`。对应员工,包括员工编号、员工名称、身份证号码、地址、邮政编码、电话号码、手机号码、qq号码、邮箱、性别、政治面貌、生日、民族、学历、所学专业爱好、备注及建档日期等属性。
- `Notice`。对应公告,包括公告编号、公告标题、公告内容、发布日期等属性.
- `Document`。对应文件,包括文件编号、文件标题、文件名、文件描述、上传时间等属性。
- 在领域模式的设计中,这6个`PO`对象也应该包含系统的业务逻辑方法,也就是使用领域模型对象来为它们建模;但本应用不打算为它们提供任何业务逻辑方法,而是将所有的业务逻辑方法放到业务逻辑组件中实现.

将所有的业务逻辑方法放到业务逻辑组件中实现,这样系统中的领域对象显得十分简洁,它们都是单纯的数据类,不需要考虑到底应该包含哪些业务逻辑方法,因此开发起来非常便捷;而系统的所有业务逻辑都由业务逻辑组件负责实现,这样可以将业务逻辑的变化限制在业务逻辑层内,从而避免扩散到其他两个层,因此降低了系统的开发难度。
客观世界中的对象不是孤立存在的,以上6个`PO`类也不是孤立存在的,它们之间存在复杂的关联关系,分析关联关系是面向对象分析的必要步骤.
这6个`PO`的关系如下:
`Dept`和`Employee`之间存在**1对N**的关系,即一个`Dept`可以有多个`Employee`。
`Employee`和`Dept`之间存在**N对1**的关系,即一个`Employee`只属于一个`Dept`。
`Employee`和`Job`之间存在**N对1**的关系,即一个`Employee`只能有一个`Job`.
`User`和`Notice`之间存在**1对N**的关系,即一个`User`可以发布多个`Notice`。
`User`和`Document`之间存在**1对N**的关系,即一个`User`可以上传多个`Document`。

## 13.2.3 创建持久化实体类 ##
- 持久化对象之间的关联关系以成员变量的方式表现出来,当然这些成员变量同样需要`setter`和`getter`方法的支持。**持久化类之间的关联关系通常对应数据库里的主、外键约束**.
- 除此之外,持久化对象还有自己的**普通类型的成员变量**,这些成员变量**通常对应数据库的字段**。

下面是6个持久化类的源代码.
### User.java ###
```java
package org.fkit.hrm.domain;
import java.io.Serializable;
import java.util.Date;
public class User
    implements Serializable
{
    private static final long serialVersionUID = 1L;
    private Integer id;			// id
    private String username;	// 用户名
    private String loginname;	// 登录名
    private String password;	// 密码
    private Integer userstatus; // 状态
    private Date createDate;	// 建档日期
    // 无参数构造器
    public User()
    {
        super();
    }
    // setter和getter方法
    // 此处省略getter和setter方法,请自己补上
    @Override
    public String toString()
    {
        return "User [id=" + id + ", username=" + username + ", loginname=" + loginname
                + ", password=" + password + ", userstatus=" + userstatus + ", createDate="
                + createDate + "]";
    }
}
```
### Dept.java ###
```java
package org.fkit.hrm.domain;
import java.io.Serializable;
public class Dept
    implements Serializable
{
    private static final long serialVersionUID = 1L;
    private Integer id;		// id
    private String name;	// 部门名称
    private String remark;	// 详细描述
    // 无参数构造器
    public Dept()
    {
        super();
    }
    // 此处省略getter和setter方法,请自己补上
    @Override
    public String toString()
    {
        return "Dept [id=" + id + ", name=" + name + ", remark=" + remark + "]";
    }
}
```
### Job.java ###
```java
package org.fkit.hrm.domain;
import java.io.Serializable;
public class Job
    implements Serializable
{
    private static final long serialVersionUID = 1L;
    private Integer id;			// id
    private String name;		// 职位名称
    private String remark;		// 详细描述
    // 无参数构造器
    public Job()
    {
        super();
    }
    // 此处省略getter和setter方法,请自己补上
    @Override
    public String toString()
    {
        return "Job [id=" + id + ", name=" + name + ", remark=" + remark + "]";
    }
}
```
### Employee.java ###
```java
package org.fkit.hrm.domain;
import org.springframework.format.annotation.DateTimeFormat;
import java.io.Serializable;
public class Employee
    implements Serializable
{
    private static final long serialVersionUID = 1L;
    private Integer id;			// id
    private Dept dept;			// 部门
    private Job job;			// 职位
    private String name;		// 名称
    private String cardId;		// 身份证
    private String address;		// 地址
    private String postCode;	// 邮政编码
    private String tel;			// 电话
    private String phone;		// 手机
    private String qqNum;		// qq
    private String email;		// 邮箱
    private Integer sex;		// 性别
    private String party;		// 政治面貌
    /**
     * 使用@ModelAttribute接收参数时 form表单中有日期,Spring不知道该如何转换,
     * 要在实体类的日期属性上加@DateTimeFormat(pattern="yyyy-MM-dd")注解
     */
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private java.util.Date birthday;	       // 生日
    private String race;				// 名族
    private String education;			// 学历
    private String speciality;			// 专业
    private String hobby;				// 爱好
    private String remark;				// 备注
    private java.util.Date createDate;	// 建档日期
    // 无参数构造器
    public Employee()
    {
        super();
    }
    // 此处省略getter和setter方法,请自己补上
    @Override
    public String toString()
    {
        return "Employee [id=" + id + ", dept=" + dept + ", job=" + job + ", name=" + name
                + ", cardId=" + cardId + ", address=" + address + ", postCode=" + postCode
                + ", tel=" + tel + ", phone=" + phone + ", qqNum=" + qqNum + ", email=" + email
                + ", sex=" + sex + ", party=" + party + ", birthday=" + birthday + ", race=" + race
                + ", education=" + education + ", speciality=" + speciality + ", hobby=" + hobby
                + ", remark=" + remark + ", createDate=" + createDate + "]";
    }
}
```
### Notice.java ###
```java
package org.fkit.hrm.domain;
import java.io.Serializable;
public class Notice
    implements Serializable
{
    private static final long serialVersionUID = 1L;
    private Integer id;		// 编号
    private String title;   // 标题
    private String content; // 内容
    private java.util.Date createDate;  // 发布日期
    private User user;		// 发布人
    // 无参数构造器
    public Notice()
    {
        super();
        // TODO Auto-generated constructor stub
    }
    // 此处省略getter和setter方法,请自己补上
    @Override
    public String toString()
    {
        return "Notice [id=" + id + ", title=" + title + ", content=" + content + ", createDate="
                + createDate + ", user=" + user + "]";
    }
}
```
### Document.java ###
```java
package org.fkit.hrm.domain;
import org.springframework.web.multipart.MultipartFile;
import java.io.Serializable;
public class Document
    implements Serializable
{
    private static final long serialVersionUID = 1L;
    private int id;					    // 编号
    private String title;			    // 标题
    private String fileName;		    // 文件名
    private MultipartFile file;		    // 文件
    private String remark;			    // 描述
    private java.util.Date createDate;  // 上传时间
    private User user;				    // 上传人
    // 无参数构造器
    public Document()
    {
        super();
        // TODO Auto-generated constructor stub
    }
    // 此处省略getter和setter方法,请自己补上
    @Override
    public String toString()
    {
        return "Document [id=" + id + ", title=" + title + ", fileName=" + fileName + ", file="
                + file + ", remark=" + remark + ", createDate=" + createDate + ", user=" + user
                + "]";
    }
}
```
<!--SSTStop-->
