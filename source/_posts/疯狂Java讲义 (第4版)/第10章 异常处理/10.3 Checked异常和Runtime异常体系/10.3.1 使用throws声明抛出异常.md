---
title: 10.3.1 使用throws声明抛出异常
categories: 
  - 疯狂Java讲义 (第4版)
  - 第10章 异常处理
  - 10.3 Checked异常和Runtime异常体系
date: 2019-07-13 17:22:50
updated: 2019-11-02 01:39:01
abbrlink: d5e8f6ca
---
- [10.3.1 使用throws声明抛出异常](/ReadingNotes/d5e8f6ca/#10-3-1-使用throws声明抛出异常)
    - [throws声明抛出异常的语法格式](/ReadingNotes/d5e8f6ca/#throws声明抛出异常的语法格式)
    - [Checked异常的缺点](/ReadingNotes/d5e8f6ca/#Checked异常的缺点)
    - [推荐使用Runtime异常](/ReadingNotes/d5e8f6ca/#推荐使用Runtime异常)
    - [不需要在方法声明中抛出Runtime异常](/ReadingNotes/d5e8f6ca/#不需要在方法声明中抛出Runtime异常)
    - [可以使用try-catch捕获Runtime异常](/ReadingNotes/d5e8f6ca/#可以使用try-catch捕获Runtime异常)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
# 10.3.1 使用throws声明抛出异常 #
使用`throws`声明抛出异常的思路是,当前方法不知道如何处理这种类型的异常,该异常应该由上级调用者处理;
如果`main`方法也不知道如何处理这种类型的异常,也可以使用`throws`声明抛出异常,该异常将交给`JVM`处理。
**`JVM`对异常的处理方法是,打印异常的跟踪栈信息,并中止程序运行**,这就是前面程序在遇到异常后自动结束的原因。

## throws声明抛出异常的语法格式 ##
`throws`声明抛出只能在方法签名中使用, `throws`可以声明抛出多个异常类,多个异常类之间以逗号隔开。

**`throws`声明抛出的语法格式仅跟在方法签名之**后,如下例子程序使用了`throws`来声明抛出`IOException`异常,**一旦使用`throws`语句声明抛出该异常,程序就无须使用`try-catch`块来捕获该异常了**。
```java
import java.io.*;

public class ThrowsTest
{
	public static void main(String[] args)
		throws IOException
	{
		FileInputStream fis = new FileInputStream("a.txt");
	}
}
```
上面程序声明不处理`IOException`异常,将该异常交给`JVM`处理,所以程序一旦遇到该异常,`JVM`就会打印该异常的跟踪栈信息,并结束程序。运行上面程序,效果如下所示:
```cmd
Exception in thread "main" java.io.FileNotFoundException: a.txt (系统找不到指定的文件。)
	at java.io.FileInputStream.open0(Native Method)
	at java.io.FileInputStream.open(FileInputStream.java:195)
	at java.io.FileInputStream.<init>(FileInputStream.java:138)
	at java.io.FileInputStream.<init>(FileInputStream.java:93)
	at ThrowsTest.main(ThrowsTest.java:8)
```
如果某段代码中调用了一个带`throws`声明的方法,该方法声明抛出了`Checked`异常,则表明该方法希望它的调用者来处理该异常。也就是说,调用该方法时要么放在`try`块中显式捕获该异常,要么放在另一个带`throws`声明抛出的方法中。如下例子程序示范了这种用法。
```java
import java.io.*;

public class ThrowsTest2
{
	public static void main(String[] args)
		throws Exception
	{
		// 因为test()方法声明抛出IOException异常，
		// 所以调用该方法的代码要么处于try...catch块中，
		// 要么处于另一个带throws声明抛出的方法中。
		test();
	}
	public static void test()throws IOException
	{
		// 因为FileInputStream的构造器声明抛出IOException异常，
		// 所以调用FileInputStream的代码要么处于try...catch块中，
		// 要么处于另一个带throws声明抛出的方法中。
		FileInputStream fis = new FileInputStream("a.txt");
	}
}
```
使用`throws`声明抛出异常时有一个限制,就是方法重写时子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或相同,子类方法声明抛出的异常不允许比父类方法声明抛出的异常多。看如下程序。
```java
import java.io.*;

public class OverrideThrows
{
	public void test()throws IOException
	{
		FileInputStream fis = new FileInputStream("a.txt");
	}
}
class Sub extends OverrideThrows
{
	// 子类方法声明抛出了比父类方法更大的异常
	// 所以下面方法出错
	public void test()throws Exception
	{
	}
}
```
上面程序中`Sub`子类中的`test()`方法声明抛出`Exception`,该`Exception`是其父类声明抛出异常`EXception`类的父类,这将导致程序无法通过编译。
## Checked异常的缺点 ##
使用`Checked`异常至少存在如下两大不便之处。
- 对于程序中的`Checked`异常,`Java`要求必须显式捕获并处理该异常,或者显式声明抛出该异常这样就增加了编程复杂度。
- 如果在方法中显式声明抛出`Checked`异常,将会导致`方法签名与异常耦合`,如果该方法是`重写父类`的方法,则该方法抛出的异常还会受到被重写方法所抛出异常的限制。

## 推荐使用Runtime异常 ##
在大部分时候推荐使用`Runtime`异常,而不使用`Checked`异常。尤其当程序需要自行抛出异常时,使用`Runtime`异常将更加简洁。
## 不需要在方法声明中抛出Runtime异常 ##
当使用`Runtime`异常时,程序无须在方法中声明抛出`Runtime`异常,一旦发生了自定义错误,程序只管抛出`Runtime`异常即可。
## 可以使用try-catch捕获Runtime异常 ##
如果程序需要在合适的地方捕获异常并对异常进行处理,则一样可以使用`try-catch`块来捕获`Runtime`异常。

使用`Runtime`异常是比较省事的方式,使用这种方式既可以享受"正常代码和错误处理代码分离","保证程序具有较好的健壮性"的优势,又可以避免因为使用`Checked`异常带来的编程烦琐性。因此,`C#`、`Ruby`、 `Python`等语言没有所谓的`Checked`异常,所有的异常都是`Runtime`异常。

但`Checked`异常也有其优势`Checked`异常能在编译时提醒程序员代码可能存在的问题,提醒程序员必须注意处理该异常,或者声明该异常由该方法调用者来处理,从而可以避免程序员因为粗心而忘记处理该异常的错误。

