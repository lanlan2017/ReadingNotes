---
title: 18.1.5 类初始化的时机
categories: 
  - 疯狂Java讲义 (第4版)
  - 第18章 类加载机制与反射
  - 18.1 类的加载 连接和初始化
date: 2019-06-16 00:12:50
updated: 2019-11-02 01:39:01
abbrlink: 4db02294
---
- [18.1.5 类初始化的时机](/ReadingNotes/4db02294/#18-1-5-类初始化的时机)
    - [访问编译时可确定类变量不会初始化类](/ReadingNotes/4db02294/#访问编译时可确定类变量不会初始化类)
    - [ClassLoader类的loadClass方法和forName方法](/ReadingNotes/4db02294/#ClassLoader类的loadClass方法和forName方法)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
# 18.1.5 类初始化的时机 #
当`Java`程序首次通过下面6种方式来使用某个类或接口时,系统就会初始化该类或接口.
- 创建类的实例。为某个类创建实例的方式包括:
    - 使用`new`操作符来创建实例,
    - 通过反射来创建实例,
    - 通过反序列化的方式来创建实例。
- 调用某个类的类方法(静态方法)
- 访问某个类或接口的类变量,或为该类变量赋值。
- 使用反射方式来强制创建某个类或接口对应的`java.lang.Class`对象。例如代码:`Class.forName("Person");`如果系统还未初始化`Person`类,则这行代码将会导致该`Person`类被初始化,并返回`Person`类对应的`java.lang.Class`对象。
- 初始化某个类的子类。当初始化某个类的子类时,该子类的所有父类都会被初始化。
- 直接使用`Java.exe`命令来运行某个主类。当运行某个主类时,程序会先初始化该主类。

## 访问编译时可确定类变量不会初始化类 ##
除此之外,下面的几种情形需要特别指出。
对于一个 `final`型的类变量,如果该类变量的值在编译时就可以确定下来,那么这个类变量相当于“宏变量”。`Java`编译器会在编译时直接把这个类变量出现的地方替换成它的值,因此即使程序使用该静态类变量,也不会导致该类的初始化。例如下面示例程序的结果：
```java
class MyTest
{
	static
	{
		System.out.println("静态初始化块...");
	}
	// 使用一个字符串直接量为static final的类变量赋值
	static final String compileConstant = "final static字符串";
}
public class CompileConstantTest
{
	public static void main(String[] args)
	{
		// 访问、输出MyTest中的compileConstant类变量
		System.out.println(MyTest.compileConstant);   // ①
	}
}
```
运行结果
```cmd
final static字符串
```
上面程序的`MyTest`类中有一个`compileConstant`的类变量,该类变量使用了`final`修饰,而且它的值可以在编译时确定下来,因此`compileConstant`会被当成"宏变量"处理。**程序中所有使用`compileConstant`的地方都会在编译时被直接替换成它的值**——也就是说,上面程序中①处的代码在编译时就会被替换成"`final static字符串`",所以①行代码不会导致初始化`MyTest`类,静态代码块将不会执行。
反之,**如果`final`修饰的类变量的值不能在编译时确定下来**,则必须等到运行时才可以确定该类变量的值,如果通过该类来访问它的类变量,则**会导致该类被初始化**。例如将上面程序中定义`compileConstant`的代码改为如下:
```java
    // 采用系统当前时间为static final类变量赋值
    static final String compileConstant = System.currentTimeMillis()+"静态字符串嘻嘻嘻";//①
```
因为上面定义的`compileConstant`类变量的值必须在运行时才可以确定,所以①处的字代码必须保留为对`MyTest`类的类变量的引用,这行代码就变成了使用`MyTest`的类变量,这将导致`MyTest`类被初始化。
运行效果如下:
```cmd
静态初始化块...
1560616123824静态字符串嘻嘻嘻
```
## ClassLoader类的loadClass方法和forName方法 ##
当使用`ClassLoader`类的`loadClass()`方法来加载某个类时,该方法只是加载该类,并不会执行该类的初始化。使用`Class`的`forName()`静态方法才会导致强制初始化该类。例如如下代码：
```java
class Tester
{
    static
    {
        System.out.println("Tester类的静态初始化块...");
    }
}
public class ClassLoaderTest
{
    public static void main(String[] args)
        throws ClassNotFoundException
    {
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        // 下面语句仅仅是加载Tester类
        cl.loadClass("Tester");//①
        System.out.println("---------------------------------------------");
        System.out.println("系统加载Tester类");
        // 下面语句才会初始化Tester类
        Class.forName("Tester");②
    }
}
```
上面程序中的代码①,②都用到了`Tester`类,代码①只是加载`Tester`类,并不会初始化`Tester`类。运行上面程序,会看到如下运行结果:
```cmd
系统加载Tester类
Tester类的静态初始化块...
```
从上面运行结果可以看出,必须等到执行`Class.forName("Tester")`时才完成对`Tester`类的初始化。

