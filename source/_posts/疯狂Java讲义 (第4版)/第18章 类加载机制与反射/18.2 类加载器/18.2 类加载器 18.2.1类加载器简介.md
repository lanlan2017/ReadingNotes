---
title: 18.2 类加载器 18.2.1类加载器简介
categories: 
  - 疯狂Java讲义 (第4版)
  - 第18章 类加载机制与反射
  - 18.2 类加载器
date: 2019-07-14 11:58:08
updated: 2019-11-02 01:39:01
abbrlink: 62d0d82f
---
- [18.2 类加载器](/ReadingNotes/62d0d82f/#18-2-类加载器)
    - [类加载器的作用](/ReadingNotes/62d0d82f/#类加载器的作用)
- [18.2.1类加载器简介](/ReadingNotes/62d0d82f/#18-2-1类加载器简介)
    - [Java中类用全限定类名作为标识](/ReadingNotes/62d0d82f/#Java中类用全限定类名作为标识)
    - [JVM中类用全限定类名和该类的类加载器作为标识](/ReadingNotes/62d0d82f/#JVM中类用全限定类名和该类的类加载器作为标识)
    - [三个类加载器](/ReadingNotes/62d0d82f/#三个类加载器)
        - [Bootstrap ClassLoader类加载器](/ReadingNotes/62d0d82f/#Bootstrap-ClassLoader类加载器)
    - [Extension ClassLoader类加载器](/ReadingNotes/62d0d82f/#Extension-ClassLoader类加载器)
    - [System ClassLoader类加载器](/ReadingNotes/62d0d82f/#System-ClassLoader类加载器)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
# 18.2 类加载器 #
## 类加载器的作用 ##
类加载器负责将`.class`文件加载到内存中,并为之生成对应的`java.lang.Class`对象。
# 18.2.1类加载器简介 #
类加载器负责加载所有的类,系统为所有被载入内存中的类生成一个`java.lang.Class`实例。**一旦个类被载入`JVM`中,同一个类就不会被再次载入了**。现在的问题是,怎么样才算"同一个类"。
正如一个对象有一个唯一的标识一样,一个载入`JVM`的类也有一个唯一的标识。
## Java中类用全限定类名作为标识 ##
在`Java`中,一个类用其`全限定类名`(包括包名和类名)作为标识;
## JVM中类用全限定类名和该类的类加载器作为标识 ##
在`JVM`中,一个类用其`全限定类名`和其`类加载器`作为其唯一标识。
例如,如果在`pg`的包中有一个名为`Person`的类,被类加载器`ClassLoader`的实例`k1`负责加载,则该`Person`类对应的`Class`象在`JVM`中表示为`(Person,pg,k1)`。
这意味着两个类加载器加载的同名类:`(Person,pg,k1)`和`(Person,pg,k2)`是不同的、它们所加载的类也是完全不同、互不兼容的。

## 三个类加载器 ##
`JVM`启动时,会形成由三个类加载器组成的初始类加载器层次结构.
- `Bootstrap Classloader`:根类加载器。
- `Extension ClassLoader`:扩展类加载器。
- `System ClassLoader`:系统类加载器。

### Bootstrap ClassLoader类加载器 ###
`Bootstrap ClassLoader`被称为引导(也称为原始或根)类加载器,它负责加载`Java`的核心类。在`Sun`的`JVM`中,当执行`java.exe`命令时,使用`-Xbootclasspath`选项或使用`-D`选项指定`sun.boot.classpath`系统属性值可以指定加载附加的类

`根类加载器`(`Bootstrap ClassLoader`)非常特殊,它并不是`java.lang.ClassLoader`的子类,而是由`JVM`自身实现的。下面程序可以获得根类加载器所加载的核心类库。
```java
import java.net.*;

public class BootstrapTest
{
	public static void main(String[] args)
	{
		// 获取根类加载器所加载的全部URL数组
		URL[] urls = sun.misc.Launcher.
		getBootstrapClassPath().getURLs();
		// 遍历、输出根类加载器加载的全部URL
		for (int i = 0; i < urls.length; i++)
		{
			System.out.println(urls[i].toExternalForm());
		}
	}
}
```
运行结果如下:
```cmd
file:/E:/java/jdk1.8.0_91/jre/lib/resources.jar
file:/E:/java/jdk1.8.0_91/jre/lib/rt.jar
file:/E:/java/jdk1.8.0_91/jre/lib/sunrsasign.jar
file:/E:/java/jdk1.8.0_91/jre/lib/jsse.jar
file:/E:/java/jdk1.8.0_91/jre/lib/jce.jar
file:/E:/java/jdk1.8.0_91/jre/lib/charsets.jar
file:/E:/java/jdk1.8.0_91/jre/lib/jfr.jar
file:/E:/java/jdk1.8.0_91/jre/classes
```
看到这个运行结果,读者应该明白为什么程序中可以使用`String`、 `System`这些核心类库—因为这些核心类库都在`rt.jar`文件中。
## Extension ClassLoader类加载器 ##
**`Extension ClassLoader`被称为`扩展类加载器`,它负责加载`JRE`的扩展目录中`JAR`包的类**,扩展目录为:`%JAVA_HOME%/jre/lib/ext`或者由`java.ext.dirs`系统属性指定的目录。
## System ClassLoader类加载器 ##
**`System ClassLoader`被称为系统类加载器,也称为应用类加载器**,它负责在`JVM`启动时加载来自`java`命令的 `-classpath`选项、 `java.class.path`系统属性,或`CLASSPATH`环境变量所指定的`JAR`包和类路径。程序可以通过`ClassLoader`的`getSystemClassLoader`静态方法来获取系统类加载器。如果没有特别指定,则用户自定义的类加载器都以系统类加载器作为父加载器。


