---
title: 16.2.3 使用Callable和Future创建线程
categories: 
  - 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.2 线程的创建和启动
date: 2019-07-15 21:44:12
updated: 2019-11-02 01:39:01
abbrlink: bf9d1ba5
---
- [16.2.3 使用Callable和Future创建线程](/ReadingNotes/bf9d1ba5/#16-2-3-使用Callable和Future创建线程)
    - [Callable接口简介](/ReadingNotes/bf9d1ba5/#Callable接口简介)
    - [Callable接口实例不能直接作为Thread的target](/ReadingNotes/bf9d1ba5/#Callable接口实例不能直接作为Thread的target)
    - [如何获取Callable接口中call()方法的返回值](/ReadingNotes/bf9d1ba5/#如何获取Callable接口中call-方法的返回值)
    - [Future接口常用方法](/ReadingNotes/bf9d1ba5/#Future接口常用方法)
    - [Callable接口是函数式接口且有泛型限制](/ReadingNotes/bf9d1ba5/#Callable接口是函数式接口且有泛型限制)
    - [创建并启动有返回值的线程的步骤](/ReadingNotes/bf9d1ba5/#创建并启动有返回值的线程的步骤)
    - [程序示例](/ReadingNotes/bf9d1ba5/#程序示例)
    - [本文重点](/ReadingNotes/bf9d1ba5/#本文重点)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 16.2.3 使用Callable和Future创建线程 #
通过实现`Runnable`接口创建多线程时, `Thread`类的作用就是把`Runnable`实例提供的`run()`方法包装成线程执行体。
## Callable接口简介 ##
从`Java 5`开始,`Java`提供了`Callable`接口,可以把该接口看成`Runnable`接口的增强版, `Callable`接口提供了一个`call()`方法可以作为线程执行体,但`call()`方法比`run()`方法功能更强大,具体表现为:
- `call()`方法可以有返回值。
- `call()`方法可以声明抛出异常。

## Callable接口实例不能直接作为Thread的target ##
`Callable`接口是`Java 5`新增的接口,但`Callable`接口不是`Runnable`接口的子接口,所以**`Callable`对象不能直接作为`Thread`的`target`**
## 如何获取Callable接口中call()方法的返回值 ##
`Java 5`提供了`Future`接口来代表`Callable`接口里`call()`方法的返回值,并为`Future`接口提供了一个`FutureTask`实现类,该实现类实现了`Future`接口,并实现了`Runnable`接口,所以**`FutureTask`可以作为`Thread`类的`target`**。

## Future接口常用方法 ##
在`Future`接口里定义了如下几个公共方法来控制它关联的`Callable`任务。

|方法|描述|
|:---|:---|
|`boolean cancel(boolean mayInterruptIfRunning)`|试图取消该`Future`里关联的`Callable`任务。|
|`V get()`|返回`Callable`任务里`call`方法的返回值。调用该方法将导致程序`阻塞`,必须等到子线程结束后才会得到返回值。|
|`V get(long timeout, TimeUnit unit)`|返回 `Callable`任务里`call`方法的返回值。该方法让程序最多阻塞`timeout`和`unit`指定的时间,如果经过指定时间后 `Callable`任务依然没有返回值,将会抛出`TimeoutException`异常。|
|`boolean isCancelled()`|如果在`Callable`任务正常完成前被取消,则返回`true`。|
|`boolean isDone()`|如果`Callable`任务已完成,则返回`true`。|
## Callable接口是函数式接口且有泛型限制 ##
`Callable`接口有泛型限制, `Callable`接口里的泛型形参类型与`call()`方法返回值类型相同且`Callable`接口是函数式接口,因此可使用`Lambda`表达式创建`Callable`对象。
## 创建并启动有返回值的线程的步骤 ##
创建并启动有返回值的线程的步骤如下。
1. 创建`Callable`接口的实现类,并实现`call()`方法,该`call()`方法将作为线程执行体,且该`call()`方法有返回值,再创建`Callable`实现类的实例。从`Java 8`开始,可以直接使用`Lambda`表达式创建`Callable`对象。
2. 使用`FutureTask`类来包装`Callable`对象,该`FutureTask`对象封装了该`Callable`对象的`call()`方法的返回值.
3. 使用`FutureTask`对象作为`Thread`对象的`target`创建并启动新线程。
4. 调用`FutureTask`对象的`get()`方法来获得子线程执行结束后的返回值。

<!--SSTStop-->
## 程序示例 ##
下面程序通过实现`Callable`接口来实现线程类,并启动该线程。
```java
import java.util.concurrent.*;

public class ThirdThread
{
	public static void main(String[] args)
	{
		// 1.先使用Lambda表达式创建Callable<Integer>对象
		// 2.使用FutureTask来包装Callable对象
		FutureTask<Integer> task = new FutureTask<Integer>((Callable<Integer>)() -> {
			int i = 0;
			for ( ; i < 100 ; i++ )
			{
				System.out.println(Thread.currentThread().getName()
					+ " 的循环变量i的值：" + i);
			}
			// call()方法可以有返回值
			return i;
		});

		for (int i = 0 ; i < 100 ; i++)
		{
			System.out.println(Thread.currentThread().getName()
				+ " 的循环变量i的值：" + i);
			if (i == 20)
			{
				// 3.实质还是以Callable对象来创建、并启动线程
				new Thread(task , "有返回值的线程").start();
			}
		}
		try
		{
			// 4.获取线程返回值
			System.out.println("子线程的返回值：" + task.get());
		}
		catch (Exception ex)
		{
			ex.printStackTrace();
		}
	}
}
```
上面程序中使用`Lambda`表达式直接创建了`Callable`对象,这样就无须先创建`Callable`实现类,再创建`Callable`对象了。实现`Callable`接口与实现`Runnable`接口并没有太大的差别,只是`Callable`的`call()`方法允许声明抛出异常,而且允许带返回值。
- 上面程序先使用`Lambda`表达式创建一个`Callable`对象,
- 然后将该实例包装成一个`FutureTask`对象。
- 主线程中当循环变量`i`等于20时,程序启动以`FutureTask`对象为`target`的线程。
- 程序最后调用`FutureTask`对象的`get()`方法来返回`call()`方法的返回值,`get()`方法将导致主线程被阻塞,直到`call()`方法结束并返回为止。

运行上面程序,将看到主线程和`call()`方法所代表的线程交替执行的情形,程序最后还会输出`call()`方法的返回值。
<!--SSTStart-->
## 本文重点 ##
创建并启动有返回值的线程的步骤如下。
1. 创建`Callable`接口的实现类,并实现`call()`方法,该`call()`方法将作为线程执行体,且该`call()`方法有返回值,再创建`Callable`实现类的实例。从`Java 8`开始,可以直接使用`Lambda`表达式创建`Callable`对象。
2. 使用`FutureTask`类来包装`Callable`对象,该`FutureTask`对象封装了该`Callable`对象的`call()`方法的返回值.
3. 使用`FutureTask`对象作为`Thread`对象的`target`创建并启动新线程。
4. 调用`FutureTask`对象的`get()`方法来获得子线程执行结束后的返回值,`get()`方法会阻塞调用它的线程(如,在主线程中调用`get()`方法,则阻塞主线程)。
<!--SSTStop-->

