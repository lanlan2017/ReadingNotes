---
title: 16.4 控制线程 16.4.1 join线程
categories: 
  - 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.4 控制线程
date: 2019-07-16 10:28:44
updated: 2019-11-02 01:39:01
abbrlink: 6fdf5d88
---
- [16.4 控制线程](/ReadingNotes/6fdf5d88/#16-4-控制线程)
- [16.4.1 join线程](/ReadingNotes/6fdf5d88/#16-4-1-join线程)
    - [join方法的功能](/ReadingNotes/6fdf5d88/#join方法的功能)
    - [谁等待谁](/ReadingNotes/6fdf5d88/#谁等待谁)
    - [程序示例](/ReadingNotes/6fdf5d88/#程序示例)
    - [join方法的重载形式](/ReadingNotes/6fdf5d88/#join方法的重载形式)
    - [本文重点](/ReadingNotes/6fdf5d88/#本文重点)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 16.4 控制线程 #
`Java`的线程支持提供了一些便捷的工具方法,通过这些便捷的工具方法可以很好地控制线程的执行.
# 16.4.1 join线程 #
## join方法的功能 ##
**`join`方法可以让一个线程等待另一个线程完成**。
## 谁等待谁 ##
当在某个程序执行流中调用其他线程的`join()`方法时,`调用线程将被阻塞`,直到被`jion()`方法加入的`join`线程执行完为止。
为了便于理解,可以把`join()`理解为`等待`,A线程中调用了B线程的`join()`方法,可以理解为A等待B执行完毕,所以,A线程被阻塞,B线程先执行.
`join`方法通常由使用线程的程序调用,以将大问题划分成许多小问题,每个小问题分配一个线程当所有的小问题都得到处理后,再调用主线程来进一步操作。
<!--SSTStop-->

## 程序示例 ##
```java
public class JoinThread extends Thread
{
	// 提供一个有参数的构造器，用于设置该线程的名字
	public JoinThread(String name)
	{
		super(name);
	}
	// 重写run()方法，定义线程执行体
	public void run()
	{
		for (int i = 0; i < 100 ; i++ )
		{
			System.out.println(getName() + "  " + i);
		}
	}
	public static void main(String[] args)throws Exception
	{
		// 启动子线程
		new JoinThread("新线程").start();
		for (int i = 0; i < 100 ; i++ )
		{
			if (i == 20)
			{
				JoinThread jt = new JoinThread("被Join的线程");
				jt.start();
				// main线程调用了jt线程的join()方法，
                // main线程必须等jt执行结束才会向下执行
				jt.join();
			}
			System.out.println(Thread.currentThread().getName()
				+ "  " + i);
		}
	}
}
```
运行效果
```cmd
---------- 运行java ----------
main  0
...
main  5
新线程  0
新线程  1
main  6
新线程  2
main  7
新线程  3
...
新线程  10
main  8
新线程  11
...
新线程  15
main  9
新线程  16
main  10
新线程  17
main  11
新线程  18
新线程  19
main  12
新线程  20
main  13
新线程  21
main  14
新线程  22
main  15
main  16
新线程  23
新线程  24
新线程  25
main  17
main  18
main  19
新线程  26
...
新线程  42
被Join的线程  0
...
被Join的线程  3
新线程  43
被Join的线程  4
新线程  44
被Join的线程  5
新线程  45
被Join的线程  6
新线程  46
被Join的线程  7
新线程  47
被Join的线程  8
新线程  48
被Join的线程  9
新线程  49
被Join的线程  10
新线程  50
被Join的线程  11
新线程  51
新线程  52
被Join的线程  12
...
被Join的线程  26
新线程  53
被Join的线程  27
新线程  54
...
新线程  61
被Join的线程  28
...
被Join的线程  56
新线程  62
被Join的线程  57
新线程  63
被Join的线程  58
...
被Join的线程  92
新线程  64
...
新线程  70
被Join的线程  93
...
被Join的线程  99
新线程  71
新线程  72
新线程  73
main  20
新线程  74
main  21
新线程  75
main  22
新线程  76
main  23
新线程  77
main  24
...
main  37
新线程  78
main  38
...
main  41
新线程  79
main  42
...
main  54
新线程  80
main  55
新线程  81
main  56
...
main  63
新线程  82
...
新线程  87
main  64
main  65
新线程  88
main  66
新线程  89
新线程  90
main  67
...
main  73
新线程  91
新线程  92
新线程  93
main  74
新线程  94
main  75
新线程  95
main  76
新线程  96
main  77
...
main  99
新线程  97
新线程  98
新线程  99
```
上面程序中一共有3个线程,主方法开始时就启动了名为"新线程"的子线程,"新线程"将会和`main`线程并发执行。当主线程的循环变量i等于20时,启动了名为"被Join的线程"的线程,"被Join的线程"不会和`main`线程并发执行,**`main`线程必须等该线程执行结束后才可以向下执行**。在名为"被`Join`的线程"的线程执行时,实际上只有`新线程`和"`被Join的线程`"这2个子线程并发执行,而主线程处于等待状态。
主线程执行到`i==20`时,程序启动并`join`了名为"被Join的线程"的线程,所以主线程将一直处于阻塞状态,直到名为"被Join的线程"的线程执行完成.

<!--SSTStart-->
## join方法的重载形式 ##
`join()`方法有如下三种重载形式

|方法|描述|
|:---|:---|
|`join()`|等待被`join`的线程执行完成。|
|`join(long millis)`|等待被`join`的线程的时间最长为`millis`毫秒。如果在`millis`毫秒内被`join`的线程还没有执行结束,则不再等待。|
|`join(long millis, int nanos)`|等待被`join`的线程的时间最长为`millis`毫秒加`nanos`毫微秒。很少使用这种形式,原因有两个:程序对时间的精度无须精确到毫微秒;计算机硬件、操作系统本身也无法精确到毫微秒。|
## 本文重点 ##
- 在当前线程中调用`B.join()`方法可理解为当前线程要`等待B线程运行结束`,
- 在A线程中,调用了B线程的`join()`方法,则A线程要`等待B线程运行结束`,
<!--SSTStop-->

