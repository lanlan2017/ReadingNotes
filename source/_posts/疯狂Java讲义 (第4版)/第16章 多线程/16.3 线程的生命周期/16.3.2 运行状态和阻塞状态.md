---
title: 16.3.2 运行状态和阻塞状态
categories: 
  - 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.3 线程的生命周期
date: 2019-07-16 09:58:14
updated: 2019-11-02 01:39:01
abbrlink: 31b1b2ca
---
- [16.3.2 运行状态和阻塞状态](/ReadingNotes/31b1b2ca/#16-3-2-运行状态和阻塞状态)
    - [什么时候线程处于运行状态](/ReadingNotes/31b1b2ca/#什么时候线程处于运行状态)
    - [什么时候线程进入阻塞状态](/ReadingNotes/31b1b2ca/#什么时候线程进入阻塞状态)
    - [什么时候线程由阻塞状态进入就绪状态](/ReadingNotes/31b1b2ca/#什么时候线程由阻塞状态进入就绪状态)
    - [线程状态转换图](/ReadingNotes/31b1b2ca/#线程状态转换图)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 16.3.2 运行状态和阻塞状态 #
## 什么时候线程处于运行状态 ##
如果**处于就绪状态的线程获得了`CPU`,开始执行`run()`方法的线程执行体,则该线程处于`运行状态`**,如果计算机只有一个`CPU`,那么在任何时刻只有一个线程处于运行状态。当然,在一个多处理器的机器上,将会有多个线程**`并行`执行**;不过当线程数大于处理器数时,依然会存在多个线程在同一个`CPU`上轮换的现象。(注意多处理器的机器上是并行: `parallel`,单处理器上是`并发`)
当一个线程开始运行后,它不可能一直处于运行状态(除非它的线程执行体足够短,瞬间就执行结束了),**线程在运行过程中需要被中断,目的是使其他线程获得执行的机会**,线程调度的细节取决于底层平台所采用的策略。对于采用`抢占式策略`的系统而言,系统会给每个可执行的线程一个`小时间段`来处理任务;当该时间段用完后,系统就会剥夺该线程所占用的资源,让其他线程获得执行的机会。在选择下一个线程时,系统会考虑线程的优先级。
所有现代的桌面和服务器操作系统都采用`抢占式调度策略`,但一些小型设备如`手机`则可能采用`协作式调度策略`,在这样的系统中,只有当一个线程调用了它的`sleep()`或`yield()`方法后才会放弃所占用的资源,也就是必须由该线程主动放弃所占用的资源。
## 什么时候线程进入阻塞状态 ##
当发生如下情况时,线程将会进入阻塞状态。
1. 线程调用`sleep()`方法主动放弃所占用的处理器资源。
2. 线程调用了一个`阻塞式IO方法`,在`阻塞式IO方法`返回之前,该线程被阻塞。
3. 线程试图获得一个同步监视器,但该`同步监视器正被其他线程所持有的时候`。
4. 线程在等待某个通知(`notify`)。
5. 程序调用了线程的`suspend()`方法将该线程挂起。但这个方法容易导致死锁,所以应该尽量避免使用该方法。

当前正在执行的线程被阻塞之后,其他线程就可以获得执行的机会。**被阻塞的线程会在合适的时候重新进入`就绪状态`**,注意是`就绪状态`而不是运行状态。也就是说,**被阻塞线程的阻塞解除后,必须重新等待线程调度器再次调度它**。
## 什么时候线程由阻塞状态进入就绪状态 ##
针对上面几种情况,当发生如下特定的情况时可以解除上面的阻塞,让该线程重新进入就绪状态。
1. 调用`sleep`方法的线程经过了指定时间
2. 线程调用的`阻塞式IO方法`已经返回。
3. 线程成功地获得了试图取得的同步监视器。
4. 线程正在等待某个通知时,`其他线程发出了一个通知`。
5. 处于挂起状态的线程被调用了`resumed()`恢复方法。

## 线程状态转换图 ##
图16.4显示了线程状态转换图。
![这里有一张图片](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/fangkuangJavaJiangYi3/16/1.png)
从图16.4中可以看出,**线程从`阻塞状态`只能进入`就绪状态`,无法直接进入运行状态**。而**就绪状态和运行状态之间的转换通常不受程序控制,而是由系统线程调度所决定**,当处于就绪状态的线程获得处理器资源时,该线程进入运行状态;当处于运行状态的线程失去处理器资源时,该线程进入就绪状态。但有个方法例外,**调用`yield()`方法可以让运行状态的线程转入就绪状态**。
<!--SSTStop-->

