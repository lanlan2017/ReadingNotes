---
title: 16.3.1 新建状态和就绪状态
categories: 
  - 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.3 线程的生命周期
date: 2019-07-16 00:50:35
updated: 2019-11-02 01:39:01
abbrlink: '53914314'
---
- [16.3.1 新建状态和就绪状态](/ReadingNotes/53914314/#16-3-1-新建状态和就绪状态)
    - [什么时候线程处于新建状态](/ReadingNotes/53914314/#什么时候线程处于新建状态)
    - [什么时候线程处于就绪状态](/ReadingNotes/53914314/#什么时候线程处于就绪状态)
    - [永远不要调用线程对象的run方法](/ReadingNotes/53914314/#永远不要调用线程对象的run方法)
    - [程序示例](/ReadingNotes/53914314/#程序示例)
    - [只能对处于新建状态的线程调用start方法](/ReadingNotes/53914314/#只能对处于新建状态的线程调用start方法)
    - [如何让子线程立即执行](/ReadingNotes/53914314/#如何让子线程立即执行)
    - [本文重点](/ReadingNotes/53914314/#本文重点)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 16.3.1 新建状态和就绪状态 #
## 什么时候线程处于新建状态 ##
**当程序使用`new`关键字创建了一个线程之后,该线程就处于`新建状态`**,此时它和其他的`Java`对象样,仅仅由`Java`虚拟机为其分配内存,并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征,程序也不会执行线程的线程执行体。
## 什么时候线程处于就绪状态 ##
**当线程对象调用了`start`方法之后,该线程处于`就绪状态`**,`Java`虚拟机会为其创建方法调用栈和程序计数器,处于这个状态中的线程并没有开始运行,只是表示该线程可以运行了。至于该线程何时开始运行,取决于`JVM`里线程调度器的调度。
## 永远不要调用线程对象的run方法 ##
启动线程使用`start()`方法,而不是`run()`方法!永远不要调用线程对象的`run()`方法!
- 调用`start()`方法来启动线程,系统会把该`run()`方法当成线程执行体来处理;
- 如果直接调用线程对象的`run()`方法,系统把线程对象当成一个普通对象,把`run()`方法当成一个普通方法,而不是线程执行体,`run()`方法将立即就会被执行,而且在`run()`方法返回之前其他线程无法并发执行
<!--SSTStop-->

## 程序示例 ##
```java
public class InvokeRun extends Thread
{
	private int i ;
	// 重写run方法，run方法的方法体就是线程执行体
	public void run()
	{
		for ( ; i < 100 ; i++ )
		{
			// 直接调用run方法时，Thread的this.getName返回的是该对象名字，
			// 而不是当前线程的名字。
			// 使用Thread.currentThread().getName()总是获取当前线程名字
			System.out.println(Thread.currentThread().getName()
				+  " " + i);   // ①
		}
	}
	public static void main(String[] args)
	{
		for (int i = 0; i < 100;  i++)
		{
			// 调用Thread的currentThread方法获取当前线程
			System.out.println(Thread.currentThread().getName()
				+  " " + i);
			if (i == 20)
			{
				// 直接调用线程对象的run方法，
				// 系统会把线程对象当成普通对象，run方法当成普通方法，
				// 所以下面两行代码并不会启动两条线程，而是依次执行两个run方法
				new InvokeRun().run();
				new InvokeRun().run();
			}
		}
	}
}
```
运行效果:
```cmd
main 0
main 1
main 2
main 3
......
main 18
main 19
main 20
main 0
main 1
main 2
......
main 44
main 45
main 46
main 47
main 48
main 49
main 0
main 1
main 2
main 3
......
main 47
main 48
main 49
```
上面程序创建线程对象后**直接调用了线程对象的`run()`方法,程序运行的结果是整个程序只有一个线程:`主线程`**。还有一点需要指出,如果直接调用线程对象的`run()`方法,则`run()`方法里不能直接通过`getName()`方法来获得当前执行线程的名字,而是需要使用`Thread.currentThread()`方法先获得当前线程,再调用线程对象的`getName()`方法来获得线程的名字。
通过上面程序不难看出,**启动线程的正确方法是调用`Thread`对象的`start()`方法,而不是直接调用`run()`方法**,否则就变成单线程程序了

<!--SSTStart-->
## 只能对处于新建状态的线程调用start方法 ##
**只能对处于新建状态的线程调用`start`方法,否则将引发`IllegalThreadStateException`异常**。调用了线程的`run()`方法之后,该线程已经不再处于新建状态,不要再次调用线程对象的`start()`方法。
调用线程对象的`start`方法之后,该线程立即进入就绪状态——就绪状态相当于"等待执行",但该线程并未真正进入运行状态。
## 如何让子线程立即执行 ##
如果希望调用子线程的`start`方法后子线程立即开始执行,程序可以使用`Thread.sleep(1)`来让`当前运行的线程(主线程)睡眠1毫秒`——1毫秒就够了,因为在这1毫秒内`CPU`不会空闲,它会去执行另一个处于就绪状态的线程,这样就可以让子线程立即开始执行。
## 本文重点 ##
- **当程序使用`new`关键字创建了一个线程之后,该线程就处于`新建状态`**
- **当线程对象调用了`start`方法之后,该线程处于`就绪状态`**,就绪状态相当于"等待执行"状态,此时该线程并未真正进入运行状态。
- **只能对处于新建状态的线程调用`start`方法,否则将引发`IllegalThreadStateException`异常**
- **启动线程的正确方法是调用`Thread`对象的`start()`方法,而不是直接调用`run()`方法**,**直接调用了线程对象的`run()`方法,程序运行的结果是整个程序只有一个线程:`主线程`**
- 如果希望调用子线程的`start`方法后子线程立即开始执行,则可以让`当前运行的线程(主线程)睡眠1毫秒`,这种情况针只有一个子线程的情况,个人觉得用处不大.
<!--SSTStop-->
