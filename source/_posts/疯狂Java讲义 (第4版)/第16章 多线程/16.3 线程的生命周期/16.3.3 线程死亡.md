---
title: 16.3.3 线程死亡
categories: 
  - 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.3 线程的生命周期
date: 2019-07-16 10:16:10
updated: 2019-11-02 01:39:01
abbrlink: 336e1e5c
---
- [16.3.3 线程死亡](/ReadingNotes/336e1e5c/#16-3-3-线程死亡)
    - [什么时候线程处于死亡状态](/ReadingNotes/336e1e5c/#什么时候线程处于死亡状态)
    - [主线程结束其他线程可继续执行](/ReadingNotes/336e1e5c/#主线程结束其他线程可继续执行)
    - [isAlive方法](/ReadingNotes/336e1e5c/#isAlive方法)
    - [已经死亡的线程无法再次启动](/ReadingNotes/336e1e5c/#已经死亡的线程无法再次启动)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 16.3.3 线程死亡 #
## 什么时候线程处于死亡状态 ##
线程会以如下三种方式结束,结束后就处于死亡状态。
- `run()`或`call()`方法执行完成,线程正常结束。
- 线程抛出一个未捕获的`Exception`或`Error`。
- 直接调用该线程的`stop()`方法来结束该线程,不过`stop()`方法容易导致死锁,通常不推荐使用。

## 主线程结束其他线程可继续执行 ##
当主线程结束时,其他线程不受任何影响,并不会随之结束。一旦子线程启动起来后,它就拥有和主线程相同的地位,它不会受主线程的影响。
## isAlive方法 ##
为了测试某个线程是否已经死亡,可以调用线程对象的`isAlive()`方法,
- 当线程处于`就绪`、`运行`、`阻塞`三种状态时,`isAlive()`方法将返回`true`;
- 当线程处于`新建`、`死亡`两种状态时,`isAlive()`方法将返回`false`

## 已经死亡的线程无法再次启动 ##
不要试图对一个已经死亡的线程调用`start`方法使它重新启动,死亡就是死亡,该线程将不可再次作为线程执行。
<!--SSTStop-->

下面程序尝试对处于死亡状态的线程再次调用`start`方法。
```java
public class StartDead extends Thread
{
    // 重写run方法，run方法的方法体就是线程执行体
    private int i ;
    public void run()
    {
        for ( ; i < 100 ; i++ )
        {
            System.out.println(getName() +  " " + i);
        }
    }
    public static void main(String[] args)
    {
        // 创建线程对象
        StartDead sd = new StartDead();
        for (int i = 0; i < 300;  i++)
        {
            // 调用Thread的currentThread方法获取当前线程
            System.out.println(Thread.currentThread().getName()
                +  " " + i);
            if (i == 20)
            {
                // 启动线程
                // 判断启动后线程的isAlive()值，输出true
                sd.start();
                System.out.println(sd.isAlive());
            }
            // 只有当线程处于新建、死亡两种状态时isAlive()方法返回false。
            // 当i > 20，则该线程肯定已经启动过了，如果sd.isAlive()为假时，
            // 那只能是死亡状态了。
            if (i > 20 && !sd.isAlive())

            {
                // 试图再次启动该线程
                sd.start();
            }
        }
    }
}
```
上面程序中试图在线程已死亡的情况下再次调用`start`方法来启动该线程。运行上面程序,将引发`IllegalThreadStateException`异常。这表明**处于死亡状态的线程无法再次运行了**。

<!--SSTStart-->
不要对处于死亡状态的线程调用`start`方法,**只能对`新建状态`的线程调用`start`方法**,**对`新建状态`的线程两次调用`start`方法也是错误的**。这都会引发`IllegalThreadStateException`异常.
<!--SSTStop-->

