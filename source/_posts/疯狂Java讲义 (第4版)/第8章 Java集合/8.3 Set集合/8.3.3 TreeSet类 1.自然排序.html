<!DOCTYPE html>
<html>
<head>
<title>8.3.3 TreeSet类 1.自然排序</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video {
    margin: 0;
    padding: 0;
    border: 0;
}

/* BODY
  =============================================================================*/

body {
    font-family: Helvetica, arial, freesans, clean, sans-serif;
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    background-color: #fff;
    padding: 20px;
    max-width: 960px;
    margin: 0 auto;
}

body>*:first-child {
    margin-top: 0 !important;
}

body>*:last-child {
    margin-bottom: 0 !important;
}

/* BLOCKS
  =============================================================================*/

p,
blockquote,
ul,
ol,
dl,
table,
pre {
    margin: 15px 0;
}

/* HEADERS
  =============================================================================*/

h1,
h2,
h3,
h4,
h5,
h6 {
    margin: 20px 0 10px;
    padding: 0;
    font-weight: bold;
    -webkit-font-smoothing: antialiased;
}

h1 tt,
h1 code,
h2 tt,
h2 code,
h3 tt,
h3 code,
h4 tt,
h4 code,
h5 tt,
h5 code,
h6 tt,
h6 code {
    font-size: inherit;
}

h1 {
    font-size: 28px;
    color: #000;
}

h2 {
    font-size: 24px;
    border-bottom: 1px solid #ccc;
    color: #000;
}

h3 {
    font-size: 18px;
}

h4 {
    font-size: 16px;
}

h5 {
    font-size: 14px;
}

h6 {
    color: #777;
    font-size: 14px;
}

body>h2:first-child,
body>h1:first-child,
body>h1:first-child+h2,
body>h3:first-child,
body>h4:first-child,
body>h5:first-child,
body>h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1+p,
h2+p,
h3+p,
h4+p,
h5+p,
h6+p {
    margin-top: 10px;
}

/* LINKS
  =============================================================================*/

a {
    color: #4183C4;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

/* LISTS
  =============================================================================*/

ul,
ol {
    padding-left: 30px;
}

ul li> :first-child,
ol li> :first-child,
ul li ul:first-of-type,
ol li ol:first-of-type,
ul li ol:first-of-type,
ol li ul:first-of-type {
    margin-top: 0px;
}

ul ul,
ul ol,
ol ol,
ol ul {
    margin-bottom: 0;
}

dl {
    padding: 0;
}

dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px;
}

dl dt:first-child {
    padding: 0;
}

dl dt>:first-child {
    margin-top: 0px;
}

dl dt>:last-child {
    margin-bottom: 0px;
}

dl dd {
    margin: 0 0 15px;
    padding: 0 15px;
}

dl dd>:first-child {
    margin-top: 0px;
}

dl dd>:last-child {
    margin-bottom: 0px;
}

/* CODE
  =============================================================================*/

pre,
code,
tt {
    font-size: 12px;
    font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code,
tt {
    margin: 0 0px;
    padding: 0px 0px;
    color: #c7254e;
    white-space: nowrap;
    /* �߿� */
    border: 1px solid #eaeaea;
    /* ������ɫ */
    background-color: #f8f8f8;
    border-radius: 3px;
}

pre>code {
    margin: 0;
    padding: 0;
    white-space: pre;
    border: none;
    background: transparent;
}

pre {
    background-color: #f8f8f8;
    border: 1px solid #ccc;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
    border-radius: 3px;
}

pre code,
pre tt {
    background-color: transparent;
    border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
  =============================================================================*/

blockquote {
    border-left: 4px solid #DDD;
    padding: 0 15px;
    color: #777;
}

blockquote>:first-child {
    margin-top: 0px;
}

blockquote>:last-child {
    margin-bottom: 0px;
}

/* HORIZONTAL RULES
  =============================================================================*/

hr {
    clear: both;
    margin: 15px 0;
    height: 0px;
    overflow: hidden;
    border: none;
    background: transparent;
    border-bottom: 4px solid #ddd;
    padding: 0;
}

/* TABLES
  =============================================================================*/
table {
    border-collapse: collapse;
}

table th {
    font-weight: bold;
}

table th,
table td {
    border: 1px solid #ccc;
    padding: 6px 13px;
}

table tr {
    border-top: 1px solid #ccc;
    background-color: #fff;
}

table tr:nth-child(2n) {
    background-color: #f8f8f8;
}

/* IMAGES
  =============================================================================*/

img {
    max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<!--侧栏目录生成代码-->
<script>
    $(document).ready(function () {
        $("h1,h2,h3,h4,h5,h6").each(function (i, item) {
            //获取标签的名字,h1,还是h2
            var tag = $(item).get(0).localName;
            //为该标签设置id属性
            $(item).attr("id", "wow" + i);
            //添加一个页内超链接,并设置class选择器
            $("#category").append('<a class="new' + tag + '" href="#wow' + i + '">' + $(item).text() +
                '</a></br>');
            //为每一个标题超链接的class属性设置左边距
            // $(".newh1").css("margin-left", 0);
            $(".newh1").css({
                "margin-left": "0px",
                "font-size": "14px"
            });
            $(".newh2").css({
                "margin-left": "20px",
                "font-size": "14px"
            });
            $(".newh3").css({
                "margin-left": "40px",
                "font-size": "14px"
            });
            $(".newh4").css({
                "margin-left": "60px",
                "font-size": "14px"
            });
            $(".newh5").css({
                "margin-left": "80px",
                "font-size": "14px"
            });
            $(".newh6").css({
                "margin-left": "100px",
                "font-size": "14px"
            });
        });
        //设置class选择器为.book-body的html内容
        $(".book-body").html($(".book-body").nextAll())
    });
    // 展开或者折叠目录功能
    function showOrCloseCategory() {
        var id = document.getElementById("category");
        var book_body = document.getElementById("book_body");
        //如果展开了
        if (id.style.display == 'block') {
            //console.log("开始展开");
            id.style.display = 'none';
            id.style.width = "0%";
            book_body.style.width = "100%";
            book_body.style.paddingleft = 0;
        }
        //如果被折叠了
        else if (id.style.display == 'none') {
            //console.log("开始折叠");
            id.style.display = 'block';
            book_body.style.width = "90%";
            id.style.width = "20%"
        }
    }
    // 返回顶部功能
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
<style type="text/css">
    @media (max-width: 1600px) {
        .book-body {
            /* padding-left: 200px; */
            padding-right: 0px;
        }
    }

    @media (max-width: 1400px) {
        .book-body {
            /* padding-left: 200px; */
            padding-right: 0px;
        }
    }

    @media (max-width: 1200px) {
        .book-body {
            /* padding-left: 300px; */
            padding-left: 0px;
        }
    }

    @media (max-width: 700px) {
        .book-body {
            padding-left: 0px;
        }
    }

    @media (min-width: 600px) {
        #category {
            /* 绝对定位 */
            position: fixed;
            /* 目录显示的位置 */
            right: 0px;
            top: 0;
            /* 目录栏的高度,这里设置为60%主要是为了不挡住返回顶部和折叠按钮 */
            height: 93%;
            /* 设置边框这样和正文对比比较明显 */
            border: 2px solid #eaeaea;
            /* 开启垂直滚动条 */
            overflow-y: scroll;
        }

        /* 返回顶部按钮样式 */
        #topButton {
            position: fixed;
            float: right;
            right: 20px;
            top: 95%;
        }

        /* 展开或者折叠 */
        #foldOrUnfold {
            position: fixed;
            float: right;
            right: 100px;
            top: 95%
        }

        /* 正文的样式 */
        #book_body {
            width: 90%;
            display: block;
        }
    }

    @media (-webkit-max-device-pixel-ratio: 1) {
        ::-webkit-scrollbar-track-piece {
            background-color: #FFF
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px
        }

        ::-webkit-scrollbar-thumb {
            background-color: #c2c2c2;
            background-clip: padding-box;
            min-height: 28px
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: #A0A0A0
        }
    }
</style>
<!--返回顶部-->
<button onclick="topFunction()" id="topButton">返回顶部</button>
<button onclick="showOrCloseCategory()" id="foldOrUnfold">折叠/展开</button>

<!--文章主体部分-->
<div class="book-body" id="book_body"> </div>
<!--目录栏，设置占用宽度为20%可以根据实际情况设置-->
<div class="book-summary" id="category" style="width:20%;display:block"></div>
</head>
<body>
<hr>
<p>title: 8.3.3 TreeSet类 1.自然排序<br>categories: </p>
<ul>
<li>疯狂Java讲义 (第4版)</li><li>第8章 Java集合</li><li>8.3 Set集合<br>date: 2019-07-07 19<img src="https://assets-cdn.github.com/images/icons/emoji/45.png" alt=":45:" title=":45:" class="emoji" align="absmiddle" height="20" width="20">54<br>updated: 2019-11-02 01<img src="https://assets-cdn.github.com/images/icons/emoji/39.png" alt=":39:" title=":39:" class="emoji" align="absmiddle" height="20" width="20">01<br>abbrlink: cd1e976c</li></ul>
<hr>
<ul>
<li><a href="/ReadingNotes/cd1e976c/#8-3-3-TreeSet类">8.3.3 TreeSet类</a></li><li><a href="/ReadingNotes/cd1e976c/#1-自然排序">1.自然排序</a><ul>
<li><a href="/ReadingNotes/cd1e976c/#TreeSet中元素的规则">TreeSet中元素的规则</a></li></ul>
</li></ul>
<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<h1 id="8-3-3-treeset-">8.3.3 TreeSet类</h1>
<h2 id="treeset-">TreeSet是自动排序的集合</h2>
<p><code>TreeSet</code>是<code>SortedSet</code>接口的实现类,正如<code>SortedSet</code>名字所暗示的, <strong><code>TreeSet</code>可以确保集合元素处于排序状态</strong>。</p>
<h2 id="treeset-">TreeSet额外方法</h2>
<p>与<code>HashSet</code>集合相比, <code>TreeSet</code>还提供了如下几个额外的方法.</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Comparator comparator()</code></td>
<td style="text-align:left">如果<code>TreeSet</code>采用了<code>定制排序</code>,则该方法<strong>返回定制排序所使用的<code>Comparator</code></strong>;如果<code>TreeSet</code>采用了自然排序,则返回<code>null</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Object first()</code></td>
<td style="text-align:left">返回集合中的第一个元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>Object last()</code></td>
<td style="text-align:left">返回集合中的最后一个元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>Object lower(Object e)</code></td>
<td style="text-align:left">返回集合中位于指定元素之前的元素(即<strong>集合中小于指定元素的最大元素</strong>,参考元素不需要是<code>TreeSet</code>集合里的元素)。</td>
</tr>
<tr>
<td style="text-align:left"><code>Object higher(Object e)</code></td>
<td style="text-align:left">返回集合中位于指定元素之后的元素(即<strong>集合中大于指定元素的最小元素</strong>,参考元素不需要是<code>TreeSet</code>集合里的元素)。</td>
</tr>
<tr>
<td style="text-align:left"><code>SortedSet subSet(Object fromElement, Object toElement)</code></td>
<td style="text-align:left">返回此<code>Set</code>的子集合,范围从<code>fromElement</code>(包含)到<code>toElement</code>(不包含)(范围前闭后开,类似<code>String</code>类的<code>substring</code>方法)。</td>
</tr>
<tr>
<td style="text-align:left"><code>SortedSet headSet(Object toElement)</code></td>
<td style="text-align:left">返回此<code>Set</code>的子集,由小于<code>toElement</code>的元素组成。</td>
</tr>
<tr>
<td style="text-align:left"><code>SortedSet tailSet(Object fromElement)</code></td>
<td style="text-align:left">返回此<code>Set</code>的子集,由大于或等于<code>fromElement</code>的元素组成。</td>
</tr>
</tbody>
</table>
<h2 id="-">小结</h2>
<p>表面上看起来这些方法很多,其实它们很简单:<strong>因为<code>TreeSet</code>中的元素是有序的</strong>,所以增加了访问第一个、前一个、后一个、最后一个元素的方法,并提供了三个从<code>TreeSet</code>中截取子<code>TreeSet</code>的方法。</p>
<h2 id="-">实例</h2>
<p>下面程序测试了<code>TreeSet</code>的通用用法。</p>
<pre><code class="lang-java">import java.util.*;

public class TreeSetTest
{
    public static void main(String[] args)
    {
        TreeSet nums = new TreeSet();
        // 向TreeSet中添加四个Integer对象
        nums.add(5);
        nums.add(2);
        nums.add(10);
        nums.add(-9);
        // 输出集合元素，看到集合元素已经处于排序状态
        System.out.println(nums);
        // 输出集合里的第一个元素
        System.out.println(nums.first()); // 输出-9
        // 输出集合里的最后一个元素
        System.out.println(nums.last());  // 输出10
        // 返回小于4的子集，不包含4
        System.out.println(nums.headSet(4)); // 输出[-9, 2]
        // 返回大于5的子集，如果Set中包含5，子集中还包含5
        System.out.println(nums.tailSet(5)); // 输出 [5, 10]
        // 返回大于等于-3，小于4的子集。
        System.out.println(nums.subSet(-3 , 4)); // 输出[2]
    }
}
</code></pre>
<p>运行效果:</p>
<pre><code class="lang-cmd">[-9, 2, 5, 10]
-9
10
[-9, 2]
[5, 10]
[2]
</code></pre>
<p>根据上面程序的运行结果即可看出, <strong><code>TreeSet</code>并不是根据元素的插入顺序进行排序的,而是根据元素实际值的<code>大小</code>来进行<code>排序</code>的</strong>.<br>与<code>HashSet</code>集合采用<code>hash</code>算法来决定元素的存储位置不同, <code>TreeSet</code>采用<code>红黑树</code>的数据结构来存储集合元素。那么<code>TreeSet</code>进行排序的规则是怎样的呢? <code>TreeSet</code>支持两种排序方法:<code>自然排序</code>和<code>定制排序</code>。<strong>在默认情况下, <code>TreeSet</code>采用自然排序</strong>。</p>
<h1 id="1-">1.自然排序</h1>
<p><code>TreeSet</code>会调用集合元素的<code>compareTo(Object object)</code>方法来比较元素之间的大小关系,然后将集合元素按<code>升序排列</code>,这种方式就是自然排序。<br><code>Java</code>提供了一个<code>Comparable</code>接口,该接口里定义了一个<code>compareTo(Object object)</code>方法,该方法返回个整数值,实现该接口的类必须实现该方法,实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时,例如<code>object1.compareTo(object2)</code>,</p>
<ul>
<li>如果该方法返回<code>0</code>,则表明这两个对象相等;</li><li>如果该方法返回一个<code>正整数</code>,则表明<code>object1</code>大于<code>object2</code>;</li><li>如果该方法返回一个<code>负整数</code>,则表明<code>object1</code>小于<code>object2</code>。</li></ul>
<h2 id="-comparable-">实现了Comparable接口的常见类</h2>
<p><code>Java</code>的一些常用类已经实现了<code>Comparable</code>接口,并提供了比较大小的标准。下面是实现了<code>Comparable</code>接口的常用类。</p>
<ul>
<li><code>BigDecimal</code>、 <code>BigInteger</code>以及所有的<code>数值型对应的包装类</code>:按它们对应的数值大小进行比较。</li><li><code>Character</code>:按字符的<code>unicode</code>值进行比较。</li><li><code>Boolean</code>:<code>true</code>对应的包装类实例大于<code>false</code>对应的包装类实例</li><li><code>String</code>:按字符串中字符的<code>unicode</code>值进行比较.</li><li><code>Date</code>、<code>Time</code>:后面的时间、日期比前面的时间、日期大。</li></ul>
<h2 id="treeset-comparable-">TreeSet中的对象必须实现Comparable接口</h2>
<p><strong>如果试图把一个对象添加到<code>TreeSet</code>时,则该对象的类必须实现<code>Comparable</code>接口,否则程序将会抛出异常</strong>。如下程序示范了这个错误。</p>
<pre><code class="lang-java">import java.util.*;

class Err{}
public class TreeSetErrorTest
{
    public static void main(String[] args)
    {
        TreeSet ts = new TreeSet();
        // 向TreeSet集合中添加两个Err对象
        ts.add(new Err());
        ts.add(new Err());  //①
    }
}
</code></pre>
<p>运行效果:</p>
<pre><code class="lang-cmd">Exception in thread &quot;main&quot; java.lang.ClassCastException: Err cannot be cast to java.lang.Comparable
    at java.util.TreeMap.compare(TreeMap.java:1290)
    at java.util.TreeMap.put(TreeMap.java:538)
    at java.util.TreeSet.add(TreeSet.java:255)
    at TreeSetErrorTest.main(TreeSetErrorTest.java:10)
</code></pre>
<ul>
<li>上面程序试图向<code>TreeSet</code>集合中添加两个<code>Err</code>对象,添加第一个对象时, <code>TreeSet</code>里没有任何元素,所以不会出现任何问题;</li><li>当添加第二个<code>Err</code>对象时, <code>TreeSet</code>就会调用该对象的<code>compareTo(Object object)</code>方法与集合中的其他元素进行比较.<ul>
<li>如果其对应的类没有实现<code>Comparable</code>接口,则会引发<code>ClassCastException</code>异常。因此,上面程序将会在①号代码处引发该异常。</li></ul>
</li></ul>
<h2 id="treeset-comparable-">TreeSet中的第一个元素可以不实现Comparable接口</h2>
<p>向<code>TreeSet</code>集合中添加元素时,只有第一个元素无须实现<code>Comparable</code>接口,后面添加的所有元素都必须实现<code>Comparable</code>接口。<br>当然这也不是一种好做法,当试图从<code>TreeSet</code>中取出元素时,依然会引发<code>ClassCastException</code>异常。<br>还有一点必须指出:大部分类在实现<code>compareTo(Object object)</code>方法时,都需要将被比较对象<code>object</code>强制类型转换成相同类型,因为只有相同类的两个实例才会比较大小。</p>
<h2 id="treeset-">TreeSet中应该存放用一个类的对象</h2>
<p>当试图把一个对象添加到<code>TreeSet</code>集合时, <code>TreeSet</code>会调用该对象的<code>compareTo(Object object)</code>方法与集合中的其他元素进行比较——这就要求集合中的其他元素与该元素是同一个类的实例。也就是说,<strong>向<code>TreeSet</code>中添加的应该是同一个类的对象,否则也会引发<code>ClassCastException</code>异常</strong>。如下程序示范了这个错误。</p>
<pre><code class="lang-java">import java.util.*;

public class TreeSetErrorTest2
{
    public static void main(String[] args)
    {
        TreeSet ts = new TreeSet();
        // 向TreeSet集合中添加两个对象
        ts.add(new String(&quot;疯狂Java讲义&quot;));
        ts.add(new Date());   // ①
    }
}
</code></pre>
<p>运行效果:</p>
<pre><code class="lang-cmd">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.util.Date
    at java.util.Date.compareTo(Date.java:131)
    at java.util.TreeMap.put(TreeMap.java:568)
    at java.util.TreeSet.add(TreeSet.java:255)
    at TreeSetErrorTest2.main(TreeSetErrorTest2.java:10)
</code></pre>
<ul>
<li>上面程序先向<code>TreeSet</code>集合中添加了一个字符串对象,这个操作完全正常。</li><li>当添加第二个<code>Date</code>对象时, <code>TreeSet</code>就会调用该对象的<code>compareTo(Object object)</code>方法与集合中的其他元素进行比较<ul>
<li><code>Date</code>对象的<code>compareTo(Object object)</code>方法无法与字符串对象比较大小,所以上面程序将在①代码处引发异常</li></ul>
</li></ul>
<p>如果向<code>TreeSet</code>中添加的对象是程序员自定义类的对象,则可以向<code>TreeSet</code>中添加多种类型的对象,前提是用户自定义类实现了<code>Comparable</code>接口,且实现<code>compareTo(Object object)</code>方法没有进行强制类型转换。但当试图取出<code>TreeSet</code>里的集合元素时,不同类型的元素依然会发生<code>ClassCastException</code>异常。</p>
<h2 id="-treeset-">总结 TreeSet只能添加同一种类的对象</h2>
<p><strong>总结起来一句话:如果希望<code>TreeSet</code>能正常运作, <code>TreeSet</code>只能添加同一种类型的对象。</strong><br>当把一个对象加入<code>TreeSet</code>集合中时, <code>TreeSet</code>调用该对象的<code>compareTo(Object object)</code>方法与容器中的其他对象比较大小,然后根据<code>红黑树</code>结构找到它的存储位置。</p>
<h2 id="-treeset-">相等的元素不会添加到TreeSet中</h2>
<p>如果两个对象通过<code>compareTo(Object object)</code>方法比较相等,新对象将无法添加到<code>TreeSet</code>集合中。</p>
<h2 id="compareto-0-treeset-">compareTo返回0则TreeSet就认为这两个对象相等</h2>
<p>对于<code>TreeSet</code>集合而言,它判断两个对象是否相等的唯一标准是:<strong>两个对象通过<code>compareTo(Object object)</code>方法比较是否返回0</strong>:</p>
<ul>
<li>如果通过<code>compareTo( Object object)</code>方法比较返回0, <code>TreeSet</code>则会认为它们相等</li><li>否则就认为它们不相等。</li></ul>
<pre><code class="lang-java">import java.util.*;

class Z implements Comparable
{
    int age;
    public Z(int age)
    {
        this.age = age;
    }
    // 重写equals()方法，总是返回true
    public boolean equals(Object object)
    {
        return true;
    }
    // 重写了compareTo(Object object)方法，总是返回1
    public int compareTo(Object object)
    {
        return 1;
    }
}
public class TreeSetTest2
{
    public static void main(String[] args)
    {
        TreeSet set = new TreeSet();
        Z z1 = new Z(6);
        set.add(z1);
        // 第二次添加同一个对象，输出true，表明添加成功
        System.out.println(set.add(z1));    //①
        // 下面输出set集合，将看到有两个元素
        System.out.println(set);
        // 修改set集合的第一个元素的age变量
         ((Z)(set.first())).age = 9;
        // 输出set集合的最后一个元素的age变量，将看到也变成了9
        System.out.println(((Z)(set.last())).age);
    }
}
</code></pre>
<p>程序中①代码行把同一个对象再次添加到<code>TreeSet</code>集合中,因为<code>z1</code>对象的<code>compareTo(Object object)</code>方法总是返回<code>1</code>,虽然它的<code>equals</code>方法总是返回<code>true</code>,但<code>TreeSet</code>会认为<code>z1</code>对象<strong>和它自己也不相等</strong>,因此<code>TreeSet</code>可以添加两个<code>z1</code>对象。图8.5显示了<code>TreeSet</code>及Z对象在内存中的存储示意图<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/fangkuangJavaJiangYi3/8/4.png" alt="这里有一张图片"><br>从图8.5可以看到<code>TreeSet</code>对象保存的两个元素的引用,实际上是同一个元素的引用(集合里放的总是<code>引用</code>)。所以当修改<code>TreeSet</code>集合里第一个元素的<code>age</code>变量后,该<code>TreeSet</code>集合里最后一个元素的<code>age</code>变量也随之改变了。</p>
<h2 id="treeset-">TreeSet中元素的规则</h2>
<p><strong>如果两个对象通过<code>equals</code>方法比较返回<code>true</code>时,这两个对象通过<code>compareTo( Object object)</code>方法比较应返回<code>0</code></strong>.</p>
<p>如果两个对象通过<code>compareTo(Object object)</code>方法比较返回0时,但它们通过<code>equals</code>方法比较返回<code>false</code>将很麻烦,因为两个对象通过<code>compareTo(Object object)</code>方法比较相等, <code>TreeSet</code>不会让第二个元素添加进去,这就会与<code>Set</code>集合的规则产生冲突。</p>
<p>如果向<code>TreeSet</code>中添加一个可变对象后,并且后面程序修改了该可变对象的实例变量,这将导致它与其他对象的大小顺序发生了改变,但<code>TreeSet</code>不会再次调整它们的顺序,甚至可能导致<code>TreeSet</code>中保存的这两个对象通过<code>compareTo(Object object)</code>方法比较返回0。下面程序演示了这种情况。</p>
<pre><code class="lang-java">import java.util.*;

class R implements Comparable
{
    int count;
    public R(int count)
    {
        this.count = count;
    }
    public String toString()
    {
        return &quot;R[count:&quot; + count + &quot;]&quot;;
    }
    // 重写equals方法，根据count来判断是否相等
    public boolean equals(Object object)
    {
        if (this == object)
        {
            return true;
        }
        if(object != null &amp;&amp; object.getClass() == R.class)
        {
            R r = (R)object;
            return r.count == this.count;
        }
        return false;
    }
    // 重写compareTo方法，根据count来比较大小
    public int compareTo(Object object)
    {
        R r = (R)object;
        return count &gt; r.count ? 1 :
            count &lt; r.count ? -1 : 0;
    }
}
public class TreeSetTest3
{
    public static void main(String[] args)
    {
        TreeSet ts = new TreeSet();
        ts.add(new R(5));
        ts.add(new R(-3));
        ts.add(new R(9));
        ts.add(new R(-2));
        // 打印TreeSet集合，集合元素是有序排列的
        System.out.println(ts);    // ①
        // 取出第一个元素
        R first = (R)ts.first();
        // 对第一个元素的count赋值
        first.count = 20;
        // 取出最后一个元素
        R last = (R)ts.last();
        // 对最后一个元素的count赋值，与第二个元素的count相同
        last.count = -2;
        // 再次输出将看到TreeSet里的元素处于无序状态，且有重复元素
        System.out.println(ts);   // ②
        // 删除实例变量被改变的元素，删除失败
        System.out.println(ts.remove(new R(-2)));   // ③
        System.out.println(ts);
        // 删除实例变量没有被改变的元素，删除成功
        System.out.println(ts.remove(new R(5)));    // ④
        System.out.println(ts);
    }
}
</code></pre>
<p>上面程序中的R对象对应的类正常重写了<code>equals()</code>方法和<code>compareTo()</code>方法,这两个方法都以R对象的<code>count</code>实例变量作为判断的依据。当程序执行①行代码时,看到程序输出的<code>Set</code>集合元素处于有序状态;<br>因为R类是一个可变类,因此可以改变R对象的<code>count</code>实例变量的值,程序后续代码行改变了该集合里第一个元素和最后一个元素的<code>count</code>实例变量的值。当程序执行②行代码输出时,将看到该集合处于无序状态,而且集合中包含了重复元素。运行上面程序,看到如下所示的结果.</p>
<pre><code class="lang-cmd">[R[count:-3], R[count:-2], R[count:5], R[count:9]]
[R[count:20], R[count:-2], R[count:5], R[count:-2]]
false
[R[count:20], R[count:-2], R[count:5], R[count:-2]]
true
[R[count:20], R[count:-2], R[count:-2]]
</code></pre>
<p>一旦改变了<code>TreeSet</code>集合里可变元素的实例变量,当再试图删除该对象时, <code>TreeSet</code>也会删除失败(甚至集合中原有的、实例变量没被修改但与修改后元素相等的元素也无法删除),所以在上面程序的③代码处,删除<code>count</code>为<code>-2</code>的R对象时,没有任何元素被删除;程序执行④代码时,可以看到删除了<code>count</code>为5的R对象,这表明<code>TreeSet</code>可以删除没有被修改实例变量、且不与其他被修改实例变量的对象重复的对象。<br><strong>注意</strong><br>当执行了④代码后, <code>Tree Set</code>会对集合中的元素重新索引(不是重新排序),接下来就可以删除<code>TreeSet</code>中的所有元素了,包括那些被修改过实例变量的元素。与<code>HashSet</code>类似的是,如果<code>TreeSet</code>中包含了可变对象,当可变对象的实例变量被修改时, <code>TreeSet</code>在处理这些对象时将非常复杂,而且容易出错。<strong>为了让程序更加健壮,推荐不要修改放入<code>HashSet</code>和<code>TreeSet</code>集合中元素的关键实例变量</strong></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
